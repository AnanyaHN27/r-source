TITLE(deriv @@ Symbolic and Algorithmic Derivatives of Simple Expressions)
USAGE(
D(expr, namevec)
deriv(expr, namevec, function.arg = NULL, tag = ".expr")
)
ALIAS(D)
ALIAS(deriv)
ALIAS(deriv.default)
ALIAS(deriv.formula)
ARGUMENTS(
ARG(expr @@ expression which should be derivated  )
ARG(namevec @@ character vector, giving the variable names with
respect to which derivatives will be computed. )
ARG(function.arg @@ ... ?? ...  )
ARG(tag @@ ... ?? ...  )
)
DESCRIPTION(
LANG(D) is modelled after its S pendant for taking simple symbolic
derivatives.
PARA
LANG(deriv) is a ITALIC(generic) function with a default and a
LANG(LINK(formula)) method.  It returns a LANG(LINK(call)) for computing
the LANG(expr) and its (partial) derivatives, simultaneously.
It uses so called ITALIC("algorithmic derivatives").
PARA
Currently, LANG(deriv.formula) just calls LANG(deriv.default) after
extracting the expression to the right of LANG(~).
)
VALUE(
LANG(D) returns an expression and therefore can easily be iterated for
higher derivatives.
PARA
LANG(deriv) returns a LANG(LINK(call)) object which becomes an
LANG(LINK(expression)) when evaluated once.
Evaluation of the latter expression returns the function values with a
LANG(".gradient") attribute containing the gradient matrix.
)
NOTE(
This help page should be fixed up by one of R\&R or someone else who
fluently speaks the language in LANG(RHOME/src/main/deriv.c).
BLANK
It's author, MM, has only got a vague idea and thinks that a help page
is better than none....
)
REFERENCES(
A. Griewank, G. F. Corliss (1991).
ITALIC(Automatic Differentiation of Algorithms: Theory, Implementation,
and Application). 
SIAM proceedings, Philadelphia.
)
SEEALSO(
LANG(LINK(nlm)) for numeric minimization which should make use of derivatives.
)
EXAMPLES(
## formula argument :
dx2x <- deriv(~ x^2,'x') ; dx2x	 
##- expression({
##-         .value <- x^2
##-         .grad <- array(0, c(length(.value), 1), list(NULL, c("x")))
##-         .grad[, "x"] <- 2 * x
##-         attr(.value, "gradient") <- .grad
##-         .value
##- })
mode(dx2x)
e.dx2x <- eval(dx2x); mode(e.dx2x)
x <- -1:2
eval(e.dx2x)
BLANK
## Something 'tougher':
trig.exp <- expression(sin(cos(x + y^2)))
D(trig.exp, c('x','y'))
BLANK
dxy <- deriv(trig.exp, c('x', 'y'))
dxy
y <- 1
eval(eval(dxy))
)
